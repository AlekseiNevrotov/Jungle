<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Чайный путь</title>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@300&display=swap" rel="stylesheet" />
<style>
  body {
    font-family: Rubik;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    height: 100vh;
    margin: 0;
    background-color: #1A1A1A;
    overflow: hidden;
  }
  .maze {
    position: relative;
    display: grid;
    grid-template-columns: repeat(10, 30px);
    grid-template-rows: repeat(10, 30px);
    gap: 0px;
    border: 10px solid #017550;
    width: 300px;
    height: 300px;
    background-color: #1A1A1A;
  }
  .cell {
    width: 30px;
    height: 30px;
    background-color: #1A1A1A;
    border: 0px solid #1A1A1A;
    position: relative;
  }
  .wall {
    background-color: #017550;
  }
  .goal {
    background-color: #8A49A1;
  }
  .player {
    position: absolute;
    width: 30px;
    height: 30px;
    background-color: #FF842C;
    border-radius: 50%;
    transition: top 0.3s ease, left 0.3s ease;
    pointer-events: none;
    z-index: 2;
  }
  #steam {
    position: absolute;
    width: 60px;
    height: 60px;
    pointer-events: none;
    z-index: 5;
    filter: drop-shadow(0 0 5px #D9D9D9);
  }
  button {
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #017550;
    color: #DDFFFE;
    border: none;
    border-radius: 30px;
    font-size: 15px;
    cursor: pointer;
    font-family: 'Rubik';
    font-weight: 300;
    transition: background-color 0.5s ease, transform 0.5s ease;
    user-select: none;
    -webkit-tap-highlight-color: transparent; 
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
  button:hover {
    background-color: #121212;
    transform: scale(1.1);
  }
  button:active {
    background-color: #017550;
    transform: scale(1.05);
  }
  .touch-hover {
    background-color: #121212 !important;
    transform: scale(1.1) !important;
    box-shadow: 0 0 10px #121212;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }
</style>
</head>
<body>
  <div class="maze" id="maze">
    <svg id="steam" viewBox="0 0 60 60" aria-hidden="true" >
      <circle cx="30" cy="50" r="4" fill="white" opacity="0.2">
        <animate attributeName="cy" values="50;20" dur="2s" repeatCount="indefinite"/>
        <animate attributeName="opacity" values="0.2;0" dur="2s" repeatCount="indefinite"/>
      </circle>
      <circle cx="35" cy="55" r="3" fill="white" opacity="0.15">
        <animate attributeName="cy" values="55;25" dur="2.5s" repeatCount="indefinite"/>
        <animate attributeName="opacity" values="0.15;0" dur="2.5s" repeatCount="indefinite"/>
      </circle>
      <circle cx="25" cy="52" r="3" fill="white" opacity="0.18">
        <animate attributeName="cy" values="52;22" dur="2.2s" repeatCount="indefinite"/>
        <animate attributeName="opacity" values="0.18;0" dur="2.2s" repeatCount="indefinite"/>
      </circle>
    </svg>
  </div>
  <button id="refreshBtn">Обновить лабиринт</button>
<script>
  const rows = 10;
  const cols = 10;
  let mazeData = generateRandomMaze();
  let playerPosition = { x: 0, y: 0 };
  const mazeContainer = document.getElementById('maze');
  const playerDiv = document.createElement('div');
  playerDiv.classList.add('player');
  mazeContainer.appendChild(playerDiv);
  const steam = document.getElementById('steam');
  function generateRandomMaze() {
    const maze = [];
    for (let y = 0; y < rows; y++) {
      maze[y] = [];
      for (let x = 0; x < cols; x++) {
        maze[y][x] = Math.random() > 0.3 ? 0 : 1;
      }
    }
    maze[0][0] = 0;
    maze[rows - 1][cols - 1] = 2;
    if (!isPathAvailable(maze)) {
      return generateRandomMaze();
    }
    return maze;
  }
  function isPathAvailable(maze) {
    const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
    const queue = [{ x: 0, y: 0 }];
    const directions = [
      { dx: 0, dy: -1 },
      { dx: 1, dy: 0 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
    ];
    visited[0][0] = true;
    while (queue.length > 0) {
      const { x, y } = queue.shift();
      if (x === cols - 1 && y === rows - 1) {
        return true;
      }
      for (const { dx, dy } of directions) {
        const nx = x + dx;
        const ny = y + dy;
        if (
          nx >= 0 &&
          ny >= 0 &&
          nx < cols &&
          ny < rows &&
          maze[ny][nx] !== 1 &&
          !visited[ny][nx]
        ) {
          visited[ny][nx] = true;
          queue.push({ x: nx, y: ny });
        }
      }
    }
    return false;
  }
  function renderMaze() {
    mazeContainer.querySelectorAll('.cell').forEach(cell => cell.remove());
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        if (mazeData[y][x] === 1) cell.classList.add('wall');
        else if (mazeData[y][x] === 2) cell.classList.add('goal');
        mazeContainer.appendChild(cell);
      }
    }
    updatePlayerPosition();
    updateSteamPosition();
  }
  function updatePlayerPosition() {
    playerDiv.style.left = playerPosition.x * 30 + 'px';
    playerDiv.style.top = playerPosition.y * 30 + 'px';
  }
  function updateSteamPosition() {
    steam.style.left = (cols - 1) * 30 + 'px';
    steam.style.top = (rows - 1) * 30 - 50 + 'px';
  }
  function generateNewMaze() {
    mazeData = generateRandomMaze();
    playerPosition = { x: 0, y: 0 };
    renderMaze();
  }
  function movePlayer(direction) {
    let newX = playerPosition.x;
    let newY = playerPosition.y;
    if (
      direction === 'up' &&
      playerPosition.y > 0 &&
      mazeData[playerPosition.y - 1][playerPosition.x] !== 1
    ) {
      newY -= 1;
    } else if (
      direction === 'down' &&
      playerPosition.y < rows - 1 &&
      mazeData[playerPosition.y + 1][playerPosition.x] !== 1
    ) {
      newY += 1;
    } else if (
      direction === 'left' &&
      playerPosition.x > 0 &&
      mazeData[playerPosition.y][playerPosition.x - 1] !== 1
    ) {
      newX -= 1;
    } else if (
      direction === 'right' &&
      playerPosition.x < cols - 1 &&
      mazeData[playerPosition.y][playerPosition.x + 1] !== 1
    ) {
      newX += 1;
    }
    if (mazeData[newY][newX] === 2) {
      alert('Поздравляем! Вы в Jungle!');
    }
    playerPosition = { x: newX, y: newY };
    updatePlayerPosition();
  }
  window.addEventListener('keydown', (event) => {
    if (event.key === 'ArrowUp') movePlayer('up');
    else if (event.key === 'ArrowDown') movePlayer('down');
    else if (event.key === 'ArrowLeft') movePlayer('left');
    else if (event.key === 'ArrowRight') movePlayer('right');
  });
  let touchStartX = 0;
  let touchStartY = 0;
  window.addEventListener('touchstart', (event) => {
    const touch = event.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
  });
  window.addEventListener('touchend', (event) => {
    const touch = event.changedTouches[0];
    const touchEndX = touch.clientX;
    const touchEndY = touch.clientY;
    const diffX = touchEndX - touchStartX;
    const diffY = touchEndY - touchStartY;
    if (Math.abs(diffX) > Math.abs(diffY)) {
      if (diffX > 0) movePlayer('right');
      else movePlayer('left');
    } else {
      if (diffY > 0) movePlayer('down');
      else movePlayer('up');
    }
  });
  const refreshBtn = document.getElementById('refreshBtn');
  refreshBtn.addEventListener('touchstart', (event) => {
    event.preventDefault();
    refreshBtn.classList.add('touch-hover');
  });
  refreshBtn.addEventListener('touchend', (event) => {
    event.preventDefault();
    refreshBtn.classList.remove('touch-hover');
    generateNewMaze();
  });
  refreshBtn.addEventListener('touchcancel', () => {
    refreshBtn.classList.remove('touch-hover');
  });
  refreshBtn.addEventListener('click', generateNewMaze);
  renderMaze();
</script>
</body>
</html>